# HTTP

### 참조
https://romromlog.tistory.com/entry/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D-3-HTTP-%EA%B8%B0%EB%B3%B8


## 1. HTTP
---

<br><br>

### **1.1. HTTP란?**

하이퍼텍스트 전송 프로토콜은 웹 상에서 서버와 클라이언트 간에 데이터를 주고받기 위한 통신 프로토콜 입니다.
HTML, TEXT, 이미지, 음성, 영상, 파일, JSON, XML (API)등 모든 형태의 데이터를 프로토콜에 담아 전송할 수 있습니다.

### **1.2. HTTP의 역사**
**팀 버너스 리(Tim Berners-Lee)** ,
[tim-Berners-Lee.jfif](..%2F..%2Ftim-Berners-Lee.jfif)
그는 무려 World Wide Web, HTML, URL 그리고 HTTP 웹의 근간이 되는 시스템을 전부 만들어 웹의 아버지라고도 불리는 컴퓨터 과학자입니다. 
HTTP는 그 이후 웹의 성장에 따라 다양한 기능과 성능 개선이 이루어졌습니다.

- ### **1.2.1 HTTP의 기원과 초기 역사**
  - HTTP/0.9 (1989): CERN(유럽 입자 물리 연구소)에서 근무하던 팀 버너스 리는 전 세계 연구자들이 쉽게 정보공유를 할 수 있게 웹이 기본 개념인 하이퍼텍스트(HYPHER TEXT)를 통해 문서를 연결하고, HTTP 프로토콜로 이를 전송하는 방식을 채택했다고 합니다.
    - 매우 단순한 프로토콜로 한줄짜리 GET 요청을 서버에 보내면 응답으로 HTML 파일을 반환 
        - GET METHOD만 지원
        - HTTP 헤더 없음, 서버의 응답으로 HTML 문서만 전송
        - 상태 코드 개념이 존재하지 않음
        - 내가 궁금했던 점 : HTTP는 여러 데이터 이미지, 음성 등등을 전송할 수 있는 프로토콜이지만 왜 하이퍼텍스트 전송 프로토콜이란 이름이 붙었는가?
            - HTTP 초기 버전은 단순한 HTML 문서(즉, 하이퍼텍스트)를 주고받는 데 주로 사용되었기 때문에 이를 기반으로 지어진 이름(HTTP)입니다.
        - **HYPHER TEXT**란 하이퍼링크로 순차적으로 연결된 문서가 아닌 비선형적으로 연결된 링크를 통해 다른 정보를 쉽게 볼 수 있는 혁신적인 개념
  - HTTP/1.0 (1996): 초기 단계에서 다양한 기능들을 추가한 버전
    - IETF(Internet Engineering Task Force) 공식적인 문서화로 정의
        - 상태 코드 추가
        - HTTP 헤더 추가 (요청 및 응답의 특성을 설명하는 정보)
        - POST, HEAD등 여러 메서드 도입 (데이터 조회 전송하는 기능 다양화)
        - 비연결성(Connectionless): 한 번의 요청-응답 시 연결 끊음. 요청마다 새로운 연결 (비효율적)
  - HTTP/1.1 (1997): 대규모 웹 어플 지원 기능 추가
    - 현재까지 널리 사용되는 버전
      - 지속 연결(Persistent Connection): HTTP/1.0 과는 다르게 요청-응답연결을 유지하여 여러 요청을 하나의 연결로 처리 (네트워크 연결 비용을 크게 절감)
      - 파이프라이닝(Pipelining): 클라이언트가 여러 요청을 동시에 보내고, 서버가 차례로 응답
      - 캐시 제어(Cache-Control): 캐시 관리 기능이 개선되어, 응답 헤더에 Cache-Control을 추가함으로써 클라이언트의 요청에 대한 캐시 처리를 세밀하게 조정할 수 있었습니다.
      - 가상 호스팅 지원: 여러 도메인이 같은 IP 주소에서 운영될 수 있도록 Host 헤더가 추가되었습니다.
      - **궁금했던 점 :** 지속 연결과 stateless의 차이점
        - 지속 연결은 네트워크 연결을 유지하는 방법과 관련된 개념입니다. 이는 Stateless와는 다른 차원의 문제입니다.
          - Stateless: HTTP는 각 요청이 독립적이며, 서버는 요청 간에 상태를 기억하지 않는다는 뜻입니다. 
          - 지속 연결: 물리적 네트워크 연결을 계속 유지해서 여러 요청을 같은 연결에서 처리함으로써 네트워크 자원을 절약하는 방법입니다.
            따라서 HTTP가 Stateless 프로토콜이라는 특성과 지속 연결이 가능하다는 사실은 서로 다른 차원의 개념으로, 상태를 유지하지 않는 프로토콜에서 네트워크 연결을 효율적으로 관리하기 위해 지속 연결을 사용하는 것입니다.
            - 1. HTTP/1.0의 비지속 연결 (Non-Persistent Connection)
            HTTP/1.0에서는 각각의 HTTP 요청-응답마다 새로운 TCP 연결을 맺고, 응답을 보내면 바로 연결을 끊었습니다.
            예를 들어, 클라이언트가 웹 페이지와 함께 해당 페이지에 포함된 이미지, 스타일시트, 스크립트를 요청할 때마다 매번 TCP 연결을 새로 열고 요청을 보내며, 응답을 받으면 즉시 연결을 끊었습니다.
            이 방식은 비효율적이었습니다. TCP 연결을 새로 맺는 과정에서 발생하는 3-way handshake와 연결 해제 과정에서 자원을 소모했기 때문에, 성능이 저하되었습니다.
            - 자세히 : 
            
              클라이언트가 하나의 HTML 페이지를 요청하면 서버와 TCP 연결을 맺고, 응답이 끝나면 그 TCP 연결이 바로 종료됩니다.
              만약 그 페이지 안에 이미지, CSS, JavaScript 파일들이 포함되어 있다면, 각 파일마다 새로운 TCP 연결을 맺고 끊어야 합니다.
              
            - 2. HTTP/1.1의 지속 연결 (Persistent Connection)
               HTTP/1.1에서는 지속 연결이 기본값이 되었습니다. 이를 통해 한 번 TCP 연결을 맺으면 여러 HTTP 요청과 응답을 처리할 때까지 그 연결을 유지할 수 있게 되었습니다.
               즉, HTTP/1.1에서는 클라이언트와 서버 간의 TCP 연결을 계속 유지하고, 클라이언트가 여러 리소스(예: HTML, 이미지, CSS 등)를 요청할 수 있게 됩니다.
               클라이언트가 여러 요청을 보내면, TCP 연결이 그 요청이 모두 처리될 때까지 끊기지 않고 유지됩니다.
               **"Connection: keep-alive"**라는 헤더를 사용해 지속 연결을 명시적으로 유지할 수도 있습니다. 하지만 HTTP/1.1에서는 기본적으로 지속 연결을 지원합니다.
               지속 연결의 장점:
               TCP 연결을 반복적으로 여닫지 않아도 되기 때문에 성능이 크게 향상됩니다.
               네트워크 자원을 절약하고, 응답 시간도 단축됩니다. (TCP 연결을 설정하고 끊는 시간과 자원이 절감되기 때문입니다.) 
  - HTTP/2 (2015): HTTP/1.1의 단점을 보완 예(연결 수의 제한, 지연 증가)
    - 성능 향상에 중점
      - HTTP/1.x는 텍스트 기반이었지만, HTTP/2는 이진(binary) 프로토콜로 개선(네트워크 효율적인 데이터 전송 가능)
        - 멀티플렉싱(MultiFlexing): 하나의 연결에서 여러 요청과 응답을 동시에 처리할 수 있어 지연 시간을 줄이고, 기존의 HTTP/1.1에서 발생하는 헤드-오브-라인 블로킹(Head-of-Line Blocking) 문제를 해결했습니다.
        - 헤더 압축(Header Compression): HPACK이라는 알고리즘을 사용해 HTTP 헤더 크기를 줄여, 데이터 전송 효율성을 높임
        - 서버 푸시(Server Push): 서버가 클라이언트 요청 없이도 클라이언트가 필요로 할 리소스를 미리 보내줄 수 있는 기능을 제공해, 웹 페이지 로딩 속도를 향상시켰습니다.
          - **궁금한 점:** 멀티플렉싱이과 헤드오브라인 블로킹이란?
            - HTTP/2에서는 하나의 TCP 연결에서 여러 요청과 응답이 동시에 이루어질 수 있도록 데이터를 스트림(Stream) 단위로 나눠서 전송합니다.
            - 즉,클라이언트가 여러 개의 요청을 보내면 각각의 요청은 서로 다른 스트림으로 구분되어 서버에 전달됩니다. 서버는 동시에 여러 응답을 처리할 수 있고, 클라이언트는 각 스트림을 통해 응답을 받습니다.
              - **궁금한 점2:** 멀티스레딩 & 비동기 처리 VS 멀티플렉싱
                - 웹 서버에 100명의 사용자가 동시에 특정 웹 페이지를 요청한다고 가정합시다. 이 경우 각 사용자는 독립적인 클라이언트로 취급되며, 각각의 요청이 서버에 도착하게 됩니다.
                  각 클라이언트의 요청은 각각 처리됩니다. 여러 사용자의 요청을 동시에 처리하기 위해서, 웹 서버는 여러 연결을 처리할 수 있는 멀티스레딩 또는 비동기 처리 등의 기술을 사용합니다.
                  멀티플렉싱은 하나의 클라이언트 내에서 여러 리소스를 동시에 처리하는 기능이지, 여러 사용자의 요청을 동시에 처리하는 것과는 별개의 문제입니다.
                - HTTP/2는 멀티플렉싱 기능을 도입하여, 하나의 TCP 연결을 사용하면서도 여러 리소스(HTML, CSS, 이미지, JavaScript 등)를 동시에 요청할 수 있게 했습니다.
                  예를 들어, HTML 파일을 다운로드하는 동안 동시에 CSS 파일, JavaScript 파일, 이미지 파일도 다운로드할 수 있습니다.
                  이 방식으로 웹 페이지 로딩 속도가 크게 개선됩니다.
                - 헤드-오브-라인 블로킹: HTTP/1.1에서는 브라우저가 하나의 리소스를 요청하면, 그 리소스가 모두 다운로드될 때까지 다음 리소스는 대기 상태에 놓이게 됩니다. 이렇게 리소스 요청이 순차적으로 이루어지기 때문에 성능이 저하될 수 있습니다.
  - HTTP/3 (2022): HTTP/3은 기존의 TCP 대신 UDP 기반의 새로운 전송 프로토콜 QUIC를 사용
    - 성능을 더욱 개선, **지연 시간(latency)**을 대폭 줄임
    - TCP는 연결 설정 과정에서 3-way handshake 등으로 인해 지연이 발생할 수 있으며, 연결 중에 패킷 손실이 발생하면 성능이 급격히 저하될 수 있습니다. 이를 해결하기 위해 구글이 QUIC 프로토콜을 개발했고, HTTP/3은 이를 기반으로 개발되었습니다.
      - QUIC은 지연 시간 감소와 손실 복구에서 더 뛰어난 성능을 발휘
      - TCP의 3-way handshake가 필요 없으며, 연결 재설정 시에도 기존의 연결 상태를 유지할 수 있어 더 빠른 연결이 가능
      - QUIC은 암호화를 기본적으로 사용해 보안성을 강화


**내가 현재까지 이해한바**: HTTP1/1 VS HTTP2 멀티플렉싱 VS HTTP3 각 UDP 고유  + 각 스트림 고유
- HTTP1/1의 단점인 헤드 오브 라인 블로킹(HEAD OF LINE BLOCKING) 고유의 스트림(HTTP 레벨 -하나의 요청-) 예) INDEX.HTML의 FORM TAG API 요청 하나의 리소스를 처리할때 다른 리소스 CSS를 처리 시 병목 현상 발생을 보완하고자 HTTP2 멀티플렉싱: 동시에 요청 응답 FORM TAG API 요청과 CSS, 이미지 등등 방식으로 바꿈.
- 하지만 HTTP2는 HTTP 레벨 (고유의 스트림(하나의 요청-응답))에서의 병목 현상은 없지만 TCP 레벨에서는 헤드 오브 라인 블로킹이 발생 예) INDEX.HTML 파일의 CSS 가 10000바이트라고 쳤을때 TCP/IP는 이 데이터를 1500 BYTE 로 쪼개어 순차적으로 전송하여 10000/1500 = 7번 정도패킷이 서버에 도달하면 재조립되는 과정에 패킷이 하나가 중간에 손실이되면 동시에 처리되는 모든 TCP 들은 ALL STOP 됩니다.
- HTTP3 는 HTTP 레벨에서도 고유의 스트림(CSS 하나)의 병목현상 X, 또한 UDP 레벨에서도 각 UDP 가 고유하기에 손실난 패킷 재전송 되어도 다른 패킷 지장없이 움직임

차이점 요약:
HTTP/1.1:

헤드 오브 라인 블로킹 문제: HTTP 요청-응답이 순차적으로 이루어지며, 하나의 리소스가 느리게 처리되면 다른 리소스도 대기해야 함.
TCP 연결: 한 번에 하나의 요청만 처리.
HTTP/2:

멀티플렉싱으로 HTTP 레벨에서 병목 문제 해결: 여러 요청을 동시에 하나의 TCP 연결에서 처리할 수 있음.
TCP 레벨에서 헤드 오브 라인 블로킹: TCP는 순서 보장과 패킷 재전송을 요구하기 때문에, 하나의 패킷이 손실되면 전체 연결이 멈춤.
HTTP/3:

멀티플렉싱 + UDP 기반의 QUIC: HTTP 레벨뿐만 아니라 UDP 레벨에서도 각 스트림과 패킷이 독립적으로 처리됨.
헤드 오브 라인 블로킹 없음: 패킷 손실이 발생해도 다른 스트림이 영향을 받지 않으며, 각 스트림의 데이터는 독립적으로 처리됨.

### **1.3. 거리에 따른 지연**
**레이턴시(latency)란?** 